#!/usr/bin/env r

# Load packages
packages <- c("dplyr",    # mutate
              "purrr",    # map_dfr
              "readxl",   # read_excel
              "janitor",  # remove_empty, clean_names
              "readr",    # type_convert, format_csv
              "docopt")   # docopt

success  <- suppressMessages(sapply(
  packages,
  library,
  logical.return = TRUE,
  character.only = TRUE
))

# Install missing packages
if (!any(success)) {
  install.packages(names(success)[!success],
                   repos = "http://cran.us.r-project.org")
}

sapply(names(success)[!success], require, character.only = TRUE) %>%
  invisible() # Suppress `sapply` output `named list()`

# Range expansion definition
# Reference: https://rosettacode.org/wiki/Range_expansion#R
range_expand <- function(text) {
  lst <- strsplit(text, ",") %>%
    unlist() %>%
    gsub("(\\d)-", "\\1:", .)
  
  sapply(lst, function (x)
    eval(parse(text = x))) %>%
    unlist(use.names = FALSE)
}

## docopt Configurations
doc <-
  'Script to combine tables across sheets by rows in an Excel file. 

Usage:
  rbindxl.R <file>
  rbindxl.R <file> [--select-regex=<expr>]
  rbindxl.R <file> [--select-positions=<ranges>]
  rbindxl.R <file> [--select-regex=<regex>] [--select-positions=<ranges>] [--skip-rows=<rows>] [--no-header] [--output-csv=FILE]
  rbindxl.R <file> --list-sheets
  rbindxl.R (-h | --help)
  rbindxl.R --version

Options:
  -h --help                       Show this screen.
  -v --version                    Show version.
  -l --list-sheets                List sheets in the Excel file.
  -r --select-regex=<expr>        Regex identify sheet names to bind.
  -p --select-positions=<ranges>  Positions of sheets to bind.
  -s --skip-rows=<rows>           Number of rows to skip from each sheet [default: 0].
  -n --no-header                  Flag to indicate if tables do not have header row.
  -o FILE --output-csv=FILE       CSV filename to save table.


Example:
 ./rbindxl.R sample.xlsx --list-sheets
 ./rbindxl.R sample.xlsx --select-regex=^RF.* --select-positions=1-2,4,6-8 --skip-rows=0 output-csv=rf-test.csv
 
Notes:
 * This script requires identical table columns and placement across all sheets.
 * If no regex or positions are specified then all sheets are used by default.
 * The `--select-positions` argument can take a comma seperated list of integers or a range of integers denoted by the starting integer separated from the end integer in the range by a dash, `-`. 
 * A `sheetname` column is added to the combined table.
 * Empty rows and columns are removed from the final combined.
 
Requirements:
 * R >= 3.4.4
 * Missing packages will be installed, so running this script the first time may take longer.
'

args <- docopt(doc, version = '\nExcel Binder - Version 1.0\n')

all_sheets <- excel_sheets(args$file)

if(args$list_sheets) {
  print(all_sheets)
  quit(save = "no")
}

if (is_null(args$select_regex)) {
  sheets_regex <- vector(mode = "list", length = 0)
} else {
  sheets_regex <- grep(args$select_regex, all_sheets, value = TRUE)
}

if (is_null(args$select_positions)) {
  sheets_positions <- vector(mode = "list", length = 0)
} else {
  sheets_positions <- all_sheets[range_expand(args$select_positions)]
}

sheets <- union(sheets_regex, sheets_positions) %>% unlist()

if (is_empty(sheets)) {
  sheets <- all_sheets
}

df <- sheets %>%
  map_dfr(
    ~ read_excel(args$file, sheet = .x, 
                 skip = as.integer(args$skip_rows),
                 col_names = (!args$no_header)) %>%
      mutate(across(everything(), as.character)) %>%
      mutate(sheetname = .x)
  )

mdf <- df %>%
  remove_empty(quiet = TRUE) %>%
  clean_names() %>%
  type_convert()

if (!is.character(args$output_csv)) {
  cat(format_csv(mdf))
} else {
  write_csv(mdf, args$output_csv, append = FALSE)
}
